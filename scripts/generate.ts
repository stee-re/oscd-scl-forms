import { mkdir, rm, writeFile } from 'node:fs/promises';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { schemas } from '../schemas/schemas.ts';
import { buildSchemaModel } from './extract-elements.ts';
import type { ElementModel, SchemaModel } from './model.ts';

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = join(__dirname, '..');
const generatedDir = join(repoRoot, 'src', 'generated');

const header = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate.ts\n\n`;

const versions = Object.keys(schemas);
const models: SchemaModel[] = versions.map(version =>
  buildSchemaModel(version, schemas[version as keyof typeof schemas]),
);

// elementName -> version -> element
const elementsByName = new Map<string, Record<string, ElementModel>>();
models.forEach(model => {
  model.elements.forEach(el => {
    const existing = elementsByName.get(el.name) ?? {};
    existing[model.version] = el;
    elementsByName.set(el.name, existing);
  });
});

function sanitizeId(input: string): string {
  return input.replace(/[^a-zA-Z0-9_]/g, '_');
}

function buildElementPaths(model: SchemaModel): Record<string, string[]> {
  const childMap = new Map<string, string[]>(
    model.elements.map(el => [el.name, el.children]),
  );
  const paths: Record<string, string[]> = {};

  const visit = (name: string, path: string[]) => {
    if (paths[name]) {
      return;
    }
    paths[name] = path;
    (childMap.get(name) ?? []).forEach(child => visit(child, [...path, child]));
  };

  if (childMap.has('SCL')) {
    visit('SCL', ['SCL']);
  }

  model.elements.forEach(el => {
    if (!paths[el.name]) {
      paths[el.name] = [el.name];
    }
  });

  return paths;
}

function storyTitle(pathSegments: string[], elementName: string): string {
  const base = pathSegments.length > 0 ? pathSegments.join('/') : elementName;
  return base.startsWith('SCL') ? base : `SCL/${base}`;
}

async function emitFormFile(
  elementName: string,
  versionsMap: Record<string, ElementModel>,
): Promise<void> {
  const elementDir = join(generatedDir, elementName);
  await mkdir(elementDir, { recursive: true });

  const importValidatorId = `validators_${sanitizeId(elementName)}`;
  const lines: string[] = [
    `${header}import { html, TemplateResult } from 'lit';`,
    "import '../../runtime/scl-element-form.js';",
    `import { validators as ${importValidatorId} } from './${elementName}.validation.js';`,
    '',
  ];

  Object.entries(versionsMap).forEach(([version, el]) => {
    lines.push(
      `const attributes_${version} = ${JSON.stringify(el.attributes, null, 2)} as const;`,
    );
    lines.push(
      `const children_${version} = ${JSON.stringify(el.children, null, 2)} as const;`,
    );
    lines.push(
      `const occurs_${version} = ${JSON.stringify(el.occurs ?? {}, null, 2)} as const;`,
    );
    lines.push('');
  });

  lines.push(
    'export type GeneratedRenderer = (doc?: XMLDocument | null) => TemplateResult;',
    'export const forms: Record<string, GeneratedRenderer> = {',
  );

  Object.keys(versionsMap).forEach(version => {
    lines.push(
      `  '${version}': (doc?: XMLDocument | null) => html\``,
      '    <scl-element-form',
      `      elementName="${elementName}"`,
      `      .attrDefs=\${attributes_${version}}`,
      `      .childNames=\${children_${version}}`,
      `      .occursMap=\${occurs_${version}}`,
      `      .validator=\${${importValidatorId}['${version}']}`,
      '      .doc=${doc}',
      '    ></scl-element-form>',
      '  `,',
    );
  });

  lines.push('};', '');

  await writeFile(
    join(elementDir, `${elementName}.form.ts`),
    lines.join('\n'),
    'utf8',
  );
}

async function emitValidatorFile(
  elementName: string,
  versionsMap: Record<string, ElementModel>,
): Promise<void> {
  const elementDir = join(generatedDir, elementName);
  await mkdir(elementDir, { recursive: true });

  const lines: string[] = [`${header}import { z } from 'zod';`, ''];

  Object.entries(versionsMap).forEach(([version, el]) => {
    const fields =
      el.attributes.length === 0
        ? ''
        : el.attributes
            .map(attr => {
              const type = attr.type.toLowerCase();
              let base = 'z.string()';
              if (type.includes('boolean')) {
                base = 'z.boolean()';
              } else if (type.includes('int') || type.includes('decimal')) {
                base = 'z.number()';
              } else if (type.includes('date') || type.includes('time')) {
                base = 'z.string()';
              }

              if (attr.fixedValue) {
                base = `${base}.refine(v => v === '${attr.fixedValue}', { message: 'Must equal ${attr.fixedValue}' })`;
              }
              if (attr.defaultValue) {
                base = `${base}.default('${attr.defaultValue}')`;
              }
              if (attr.use !== 'required') {
                base = `${base}.optional()`;
              }
              return `  ${JSON.stringify(attr.name)}: ${base}`;
            })
            .join(',\n');

    const childFields =
      el.children.length === 0
        ? ''
        : el.children
            .map(child => {
              const occ = el.occurs?.[child];
              const min = occ?.min ?? 0;
              const max = occ?.max;
              const arr =
                max && max !== 'unbounded'
                  ? `z.array(z.any()).min(${min}).max(${max})`
                  : `z.array(z.any()).min(${min})`;
              return `  ${JSON.stringify(child)}: ${arr}.optional()`;
            })
            .join(',\n');

    const shapeEntries = [fields, childFields].filter(Boolean).join(',\n');
    const shape = shapeEntries ? `{\n${shapeEntries}\n}` : '{}';
    lines.push(`const shape_${version} = ${shape};`, '');
  });

  lines.push('export const validators: Record<string, z.ZodTypeAny> = {');
  Object.keys(versionsMap).forEach(version => {
    lines.push(`  '${version}': z.object(shape_${version}) as z.ZodTypeAny,`);
  });
  lines.push('};', '');

  await writeFile(
    join(elementDir, `${elementName}.validation.ts`),
    lines.join('\n'),
    'utf8',
  );
}

async function emitStoryFile(
  elementName: string,
  pathSegments: string[],
  elementVersions: string[],
): Promise<void> {
  const elementDir = join(generatedDir, elementName);
  await mkdir(elementDir, { recursive: true });
  const title = storyTitle(pathSegments, elementName);
  const defaultVersion = elementVersions[elementVersions.length - 1];
  const lines: string[] = [
    `${header}import type { Meta, StoryObj } from '@storybook/web-components';`,
    `import { html } from 'lit';`,
    `import '../../../stories/support/scl-sample-harness.js';`,
    '',
    `const elementVersions = ${JSON.stringify(elementVersions)} as const;`,
    '',
    `const meta: Meta = {`,
    `  title: '${title}',`,
    `  parameters: { layout: 'fullscreen' },`,
    `};`,
    '',
    'export default meta;',
    '',
    'type Story = StoryObj<{ version: (typeof elementVersions)[number] }>; ',
    '',
    'export const Playground: Story = {',
    `  args: { version: '${defaultVersion}' as (typeof elementVersions)[number] },`,
    "  argTypes: { version: { control: 'select', options: elementVersions } },",
    '  render: ({ version }, { globals: { sclDoc } }) => html`',
    '    <scl-sample-harness',
    '      .sample=${sclDoc}',
    '      .version=${version}',
    `      elementName=${JSON.stringify(elementName)}`,
    '    ></scl-sample-harness>',
    '  `,',
    '};',
    '',
  ];

  await writeFile(
    join(elementDir, `${elementName}.stories.ts`),
    lines.join('\n'),
    'utf8',
  );
}

async function emitSpecFile(elementName: string): Promise<void> {
  const elementDir = join(generatedDir, elementName);
  await mkdir(elementDir, { recursive: true });
  const lines = [
    `${header}// Placeholder tests for ${elementName}.`,
    '// TODO: add real generated coverage once renderers/validators are complete.',
    '',
    'export {};',
    '',
  ];
  await writeFile(
    join(elementDir, `${elementName}.spec.ts`),
    lines.join('\n'),
    'utf8',
  );
}

async function genFormsIndex(): Promise<string> {
  const imports: string[] = [];
  const body: string[] = [];

  Array.from(elementsByName.keys())
    .sort()
    .forEach(name => {
      const id = `forms_${sanitizeId(name)}`;
      imports.push(
        `import { forms as ${id} } from './${name}/${name}.form.js';`,
      );
    });

  versions.forEach(version => {
    const entries: string[] = [];
    elementsByName.forEach((map, name) => {
      if (map[version]) {
        const id = `forms_${sanitizeId(name)}`;
        entries.push(`    '${name}': ${id}['${version}'],`);
      }
    });
    body.push(`  '${version}': {\n${entries.join('\n')}\n  }`);
  });

  return `${header}${imports.join('\n')}\n\nimport type { TemplateResult } from 'lit';\n\nexport type GeneratedRenderer = (doc?: XMLDocument | null) => TemplateResult;\nexport const formRenderers: Record<string, Record<string, GeneratedRenderer>> = {\n${body.join(',\n')}\n};\n`;
}

async function genValidatorsIndex(): Promise<string> {
  const imports: string[] = [];
  const body: string[] = [];

  Array.from(elementsByName.keys())
    .sort()
    .forEach(name => {
      const id = `validators_${sanitizeId(name)}`;
      imports.push(
        `import { validators as ${id} } from './${name}/${name}.validation.js';`,
      );
    });

  versions.forEach(version => {
    const entries: string[] = [];
    elementsByName.forEach((map, name) => {
      if (map[version]) {
        const id = `validators_${sanitizeId(name)}`;
        entries.push(`    '${name}': ${id}['${version}'],`);
      }
    });
    body.push(`  '${version}': {\n${entries.join('\n')}\n  }`);
  });

  return `${header}${imports.join('\n')}\n\nimport type { ZodTypeAny } from 'zod';\n\nexport const validatorSchemas: Record<string, Record<string, ZodTypeAny>> = {\n${body.join(',\n')}\n};\n`;
}

function genVersions(): string {
  return `${header}export const availableVersions = ${JSON.stringify(versions, null, 2)} as const;\nexport type AvailableVersion = typeof availableVersions[number];\n`;
}

// Start fresh.
await rm(generatedDir, { recursive: true, force: true });
await mkdir(generatedDir, { recursive: true });

// Build element paths from latest model to keep titles stable.
const latestModel = models[models.length - 1];
const paths = buildElementPaths(latestModel);

// Emit per-element bundles.
for (const [elementName, versionMap] of elementsByName.entries()) {
  await emitValidatorFile(elementName, versionMap);
  await emitFormFile(elementName, versionMap);
  const pathSegments = paths[elementName] ?? [elementName];
  const elementVersions = Object.keys(versionMap).sort(
    (a, b) => versions.indexOf(a) - versions.indexOf(b),
  );
  await emitStoryFile(elementName, pathSegments, elementVersions);
  await emitSpecFile(elementName);
}

// Emit indexes.
await writeFile(join(generatedDir, 'forms.ts'), await genFormsIndex(), 'utf8');
await writeFile(
  join(generatedDir, 'validators.ts'),
  await genValidatorsIndex(),
  'utf8',
);
await writeFile(join(generatedDir, 'versions.ts'), genVersions(), 'utf8');

console.log(
  `Generated placeholder artifacts for versions: ${versions.join(', ')}`,
);
