import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { schemas } from '../schemas/schemas.ts';
import { buildSchemaModel } from './extract-elements.ts';
import type { SchemaModel } from './model.ts';

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = join(__dirname, '..');
const generatedDir = join(repoRoot, 'src', 'generated');
const formsDir = join(generatedDir, 'forms');
const validatorsDir = join(generatedDir, 'validators');

const header = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/generate.ts\n\n`;

await mkdir(generatedDir, { recursive: true });
await mkdir(formsDir, { recursive: true });
await mkdir(validatorsDir, { recursive: true });

const versions = Object.keys(schemas);
const models: SchemaModel[] = versions.map(version =>
  buildSchemaModel(version, schemas[version as keyof typeof schemas]),
);

function sanitizeId(input: string): string {
  return input.replace(/[^a-zA-Z0-9_]/g, '_');
}

async function emitFormFile(
  version: string,
  elementName: string,
  attributes: SchemaModel['elements'][number]['attributes'],
  children: string[],
  occurs?: Record<string, { min: number; max: number | 'unbounded' }>,
): Promise<void> {
  const destDir = join(formsDir, version);
  await mkdir(destDir, { recursive: true });
  const lines = [
    `${header}import { html, TemplateResult } from 'lit';`,
    "import '../../../runtime/scl-element-form.js';",
    `import { validator } from '../../validators/${version}/${elementName}.js';`,
    '',
    `const attributes = ${JSON.stringify(attributes, null, 2)} as const;`,
    `const children = ${JSON.stringify(children, null, 2)} as const;`,
    `const occurs = ${JSON.stringify(occurs ?? {}, null, 2)} as const;`,
    '',
    'export type GeneratedRenderer = (doc?: XMLDocument | null) => TemplateResult;',
    '',
    'export const form: GeneratedRenderer = (doc?: XMLDocument | null) => html`',
    `  <scl-element-form`,
    `    elementName=${elementName}`,
    `    .attrDefs=${'${attributes}'}`,
    `    .childNames=${'${children}'}`,
    `    .occursMap=${'${occurs}'}`,
    `    .validator=${'${validator}'}`,
    `    .doc=${'${doc}'}`,
    `  ></scl-element-form>`,
    '`;',
    '',
  ];
  const content = lines.join('\n');
  await writeFile(join(destDir, `${elementName}.ts`), content, 'utf8');
}

async function emitValidatorFile(
  version: string,
  elementName: string,
  attributes: SchemaModel['elements'][number]['attributes'],
  children: string[],
  occurs?: Record<string, { min: number; max: number | 'unbounded' }>,
): Promise<void> {
  const destDir = join(validatorsDir, version);
  await mkdir(destDir, { recursive: true });
  const fields =
    attributes.length === 0
      ? ''
      : attributes
          .map(attr => {
            const type = attr.type.toLowerCase();
            let base = 'z.string()';
            if (type.includes('boolean')) {
              base = 'z.boolean()';
            } else if (type.includes('int') || type.includes('decimal')) {
              base = 'z.number()';
            } else if (type.includes('date') || type.includes('time')) {
              base = 'z.string()';
            }

            if (attr.fixedValue) {
              base = `${base}.refine(v => v === '${attr.fixedValue}', { message: 'Must equal ${attr.fixedValue}' })`;
            }
            if (attr.defaultValue) {
              base = `${base}.default('${attr.defaultValue}')`;
            }
            if (attr.use !== 'required') {
              base = `${base}.optional()`;
            }
            return `  ${JSON.stringify(attr.name)}: ${base}`;
          })
          .join(',\n');

  const childFields =
    children.length === 0
      ? ''
      : children
          .map(child => {
            const occ = occurs?.[child];
            const min = occ?.min ?? 0;
            const max = occ?.max;
            const arr =
              max && max !== 'unbounded'
                ? `z.array(z.any()).min(${min}).max(${max})`
                : `z.array(z.any()).min(${min})`;
            return `  ${JSON.stringify(child)}: ${arr}.optional()`;
          })
          .join(',\n');

  const shapeEntries = [fields, childFields].filter(Boolean).join(',\n');
  const shape = shapeEntries ? `{\n${shapeEntries}\n}` : '{}';
  const content = [
    `${header}import { z } from 'zod';`,
    '',
    `const shape = ${shape};`,
    '',
    'export const validator = z.object(shape) as z.ZodTypeAny;',
    '',
  ].join('\n');
  await writeFile(join(destDir, `${elementName}.ts`), content, 'utf8');
}

async function genFormsIndex(): Promise<string> {
  const imports: string[] = [];
  const body: string[] = [];

  models.forEach(model => {
    const entries = model.elements
      .map(element => {
        const id = `form_${sanitizeId(model.version)}_${sanitizeId(element.name)}`;
        imports.push(
          `import { form as ${id} } from './forms/${model.version}/${element.name}.js';`,
        );
        return `    '${element.name}': ${id},`;
      })
      .join('\n');
    body.push(`  '${model.version}': {\n${entries}\n  }`);
  });

  return `${header}${imports.join('\n')}\n\nimport type { TemplateResult } from 'lit';\n\nexport type GeneratedRenderer = (doc?: XMLDocument | null) => TemplateResult;\nexport const formRenderers: Record<string, Record<string, GeneratedRenderer>> = {\n${body.join(',\n')}\n};\n`;
}

async function genValidatorsIndex(): Promise<string> {
  const imports: string[] = [];
  const body: string[] = [];

  models.forEach(model => {
    const entries = model.elements
      .map(element => {
        const id = `validator_${sanitizeId(model.version)}_${sanitizeId(
          element.name,
        )}`;
        imports.push(
          `import { validator as ${id} } from './validators/${model.version}/${element.name}.js';`,
        );
        return `    '${element.name}': ${id},`;
      })
      .join('\n');
    body.push(`  '${model.version}': {\n${entries}\n  }`);
  });

  return `${header}${imports.join('\n')}\n\nimport type { ZodTypeAny } from 'zod';\n\nexport const validatorSchemas: Record<string, Record<string, ZodTypeAny>> = {\n${body.join(',\n')}\n};\n`;
}

function genVersions(): string {
  return `${header}export const availableVersions = ${JSON.stringify(versions, null, 2)} as const;\nexport type AvailableVersion = typeof availableVersions[number];\n`;
}

// Emit per-element files.
for (const model of models) {
  for (const element of model.elements) {
    await emitFormFile(
      model.version,
      element.name,
      element.attributes,
      element.children,
      element.occurs,
    );
    await emitValidatorFile(
      model.version,
      element.name,
      element.attributes,
      element.children,
      element.occurs,
    );
  }
}

// Emit index files.
await writeFile(join(generatedDir, 'forms.ts'), await genFormsIndex(), 'utf8');
await writeFile(
  join(generatedDir, 'validators.ts'),
  await genValidatorsIndex(),
  'utf8',
);
await writeFile(join(generatedDir, 'versions.ts'), genVersions(), 'utf8');

console.log(
  `Generated placeholder artifacts for versions: ${versions.join(', ')}`,
);
